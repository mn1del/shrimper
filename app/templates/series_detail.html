{% extends 'base.html' %}

{% block content %}
{% if selected_race %}
<div class="d-flex align-items-center mb-3">
  <a href="{{ url_for('main.races') }}">Races</a>
  <select class="form-select w-auto ms-2" onchange="window.location=this.value">
    {% for race in all_races|sort(attribute='date', reverse=True) %}
      <option value="{{ url_for('main.race_sheet', race_id=race.race_id) }}" {% if race.race_id == selected_race.race_id %}selected{% endif %}>{{ race.date|dmy_date }} {{ race.start_time or '' }} ({{ race.series_name }})</option>
    {% endfor %}
  </select>
</div>
<div class="d-flex justify-content-end mb-2 align-items-center">
  <button type="button" class="btn btn-success me-2 d-none" id="saveChanges">Save Changes</button>
  <button type="button" class="btn btn-danger me-2 d-none" id="cancelChanges">Cancel Changes</button>
  <button type="button" class="btn btn-outline-secondary" id="editToggle">ðŸ”’</button>
</div>
<div class="card mb-3">
  <div class="card-body">
    {% if errors %}
    <div class="alert alert-danger" role="alert">
      <div class="fw-bold mb-1">Cannot calculate results due to the following issues:</div>
      <ul class="mb-0">
        {% for e in errors %}
          <li>{{ e }}</li>
        {% endfor %}
      </ul>
    </div>
    {% endif %}
    <div class="row mb-3">
      <label class="col-md-3 col-form-label">Series</label>
      <div class="col-md-9">
        <select class="form-select" id="series_id" disabled>
          {% for s in series_list %}
            <option value="{{ s.series_id }}" {% if series.series_id == s.series_id %}selected{% endif %}>{{ s.name }}</option>
          {% endfor %}
          <option value="__new__">Create New Series</option>
        </select>
      </div>
    </div>
    <div id="new-series-fields" style="display:none;">
      <div class="row mb-3">
        <label class="col-md-3 col-form-label">Series Name</label>
        <div class="col-md-9">
          <input type="text" id="new_series_name" class="form-control" disabled>
        </div>
      </div>
    </div>
    <div class="row mb-3">
      <label class="col-md-3 col-form-label">Race Date</label>
      <div class="col-md-9">
        <input type="date" id="race_date" class="form-control" value="{{ selected_race.date }}" disabled>
      </div>
    </div>
    <div class="row mb-3">
      <label for="start_time" class="col-md-3 col-form-label">Start Time</label>
      <div class="col-md-9">
        <div class="input-group">
          <input type="text" id="start_time" inputmode="numeric" pattern="^\\d{1,2}(:?\\d{2})?(:?\\d{2})?$" class="form-control" value="{{ selected_race.start_time or '' }}" disabled>
          <button type="button" class="btn btn-outline-secondary clear-time" aria-label="Clear start time" title="Clear" >&times;</button>
        </div>
      </div>
    </div>
    <div class="row mb-3">
      <label class="col-md-3 col-form-label">Finishers</label>
      <div class="col-md-9">
        <div id="finisherCount">{{ finisher_display }}</div>
      </div>
    </div>
  </div>
</div>
{% else %}
<h1>{{ series.name }}</h1>
<form method="get" class="mb-3">
  <select name="race_id" class="form-select" onchange="this.form.submit()">
    <option value="">Select a race</option>
    {% for race in races|sort(attribute='date', reverse=True) %}
      <option value="{{ race.race_id }}">{{ race.name }} ({{ race.date|dmy_date }})</option>
    {% endfor %}
    <option value="__new__">Create New Race</option>
  </select>
</form>
{% endif %}

{% if selected_race %}
<script>
  // Embedded compact scoring settings for client-side parity with server
  window.SCORING_SETTINGS = {{ (scoring_settings or {}) | tojson }};
  window.SCORING_VERSION = {{ (scoring_version or 0) | tojson }};
  // Embedded pre-race seeds (seconds per hour) for this race
  // Map: { competitor_id: initial_handicap_s_per_hr }
  window.PRE_RACE_SEEDS = {{ (pre_race_seeds or {}) | tojson }};
  // Example shape:
  // SCORING_SETTINGS = { version, handicap_delta_by_rank: [{rank, delta_s_per_hr}], league_points_by_rank: [{rank, points}], fleet_size_factor: [{finishers, factor}] }
  // SCORING_VERSION is an integer counter incremented on settings save.
</script>
<script src="{{ url_for('static', filename='scoring.js') }}"></script>
<style>
  .race-table-wrapper {
    max-height: 600px; /* roughly 15 rows */
    overflow-y: auto;
  }
  .race-table-wrapper thead th {
    position: sticky;
    top: 0;
    z-index: 1;
    background-color: #343a40; /* slightly lighter than navbar bg-dark */
    color: #fff;               /* match navbar-dark text */
    font-family: var(--bs-body-font-family);
    white-space: normal;
  }
  .race-table-wrapper tbody td {
    white-space: nowrap;
  }
  #confirmModal .modal-content {
    display: flex;
    flex-direction: column;
    height: 100%;
  }
  #confirmModal .modal-body {
    overflow-y: auto;
  }
  @media (max-width: 576px) {
    #confirmModal .modal-dialog {
      margin: 0;
      height: 100%;
      display: flex;
      align-items: flex-end;
    }
    #confirmModal.fade .modal-dialog {
      transition: transform .3s ease-out;
      transform: translateY(100%);
    }
    #confirmModal.show .modal-dialog {
      transform: translateY(0);
    }
    #confirmModal .modal-content {
      border-radius: 0;
    }
  }
  /* Ensure Hcp input fits at least 5 characters */
  .handicap-override {
    min-width: 8ch;
  }
  /* Invalid time highlight */
  td.finish-time-cell.time-invalid { background-color: #f8d7da; }
  /* Make finish time column wider for input + clear button */
  td.finish-time-cell { min-width: 16ch; }
  /* Hide native time picker icons */
  input[type="time"]::-webkit-calendar-picker-indicator { display: none; }
  input[type="time"]::-webkit-clear-button { display: none; }
  input[type="time"]::-ms-clear { display: none; }
  input[type="time"] { appearance: textfield; -moz-appearance: textfield; }
  /* Tasteful highlight for key scoring columns */
  .race-table-wrapper tbody td.race-pts,
  .race-table-wrapper tbody td.league-pts {
    background-color: #eef7ff; /* soft blue highlight */
  }
  /* Revised handicap specifically: white background for body cells */
  .race-table-wrapper tbody td.revised-hcp {
    background-color: #ffffff;
  }
  /* Adjusted Hcp Change visual formatting */
  .race-table-wrapper tbody td.actual-delta { white-space: nowrap; }
  .race-table-wrapper tbody td.actual-delta.delta-pos {
    background-color: #f8d7da; /* light red */
    color: #b02a37; /* bootstrap danger text */
    font-weight: 600;
  }
  .race-table-wrapper tbody td.actual-delta.delta-neg {
    background-color: #d1e7dd; /* light green */
    color: #0f5132; /* bootstrap success text */
    font-weight: 600;
  }
  .race-table-wrapper tbody td.actual-delta.delta-zero {
    background-color: #ffffff; /* white */
    color: inherit;
    font-weight: 600;
  }
  .delta { display: inline-flex; align-items: center; gap: 0.25rem; }
  .delta .icon { font-size: 0.85em; line-height: 1; }

  /* Visual white separator for selected header cells */
  .race-table-wrapper thead th.sep-right {
    box-shadow: inset -1px 0 0 #ffffff; /* crisp 1px white divider on right edge */
  }

  /* Post-Finish columns: light grey background */
  .race-table-wrapper tbody td.post-finish-col {
    background-color: #f5f5f5; /* light grey */
    color: #212529;            /* standard text */
  }
  /* Finish Time column: light blue background and normal control contrast */
  .race-table-wrapper tbody td.finish-time-cell {
    background-color: #e6f7ff; /* light blue */
    color: #212529;            /* dark text for readability */
  }
  .race-table-wrapper tbody td.finish-time-cell input.form-control {
    background-color: #ffffff; /* default input bg */
    color: #212529;
    border-color: #ced4da;     /* default border */
  }
  .race-table-wrapper tbody td.finish-time-cell .btn {
    color: #212529;            /* inherit dark text for outline btn */
    border-color: #6c757d;     /* secondary outline */
  }
  /* Invalid finish time on light background remains readable */
  /* (dark inversion removed; rely on the earlier light red rule) */
</style>

<div class="table-responsive race-table-wrapper">
  <table class="table table-bordered table-sm align-middle sortable">
    <thead class="table-light">
      <tr>
        <th style="width: 60px;">Hcp Pos</th>
        <th style="width: 150px;">Elapsed Time (hh:mm:ss)</th>
        <th style="width: 120px;">Adj Time (hh:mm:ss)</th>
        <th class="sep-right" style="width: 150px;">Sailor</th>
        <th style="width: 150px;">Boat</th>
        <th style="width: 80px;">Sail No.</th>
        <th style="width: 110px;">Hcp (s/hr)</th>
        <th style="width: 140px;">Adjusted Hcp Change (s/hr)</th>
        <th class="col-revised-hcp sep-right" style="width: 140px;">Revised Handicap</th>
        <th style="width: 120px;">Finish Time (hh:mm:ss)</th>
        <th style="width: 60px;">Abs Pos</th>
        <!-- Remaining columns in their previous relative order -->
        <th class="col-race-pts sep-right" style="width: 70px;">Race Pts (Trad)</th>
        <th class="col-league-pts" style="width: 70px;">League Pts (Adj)</th>
        <th style="width: 110px;">On Course Time (s)</th>
        <th class="sep-right" style="width: 110px;">Hcp Allowance (s)</th>
        <th style="width: 120px;">Full Hcp Change (s/hr)</th>
        <th style="width: 80px;">Fleet Adj (%)</th>
      </tr>
    </thead>
    <tbody>
    {% for comp in fleet %}
      {% set result = (selected_race.results or {}).get(comp.competitor_id, {}) %}
      <tr data-cid="{{ comp.competitor_id }}">
        <td class="hcp-pos">{{ result.hcp_pos|int if result.hcp_pos is defined and result.hcp_pos is not none else '' }}</td>
        <td class="elapsed-time">{% if result.on_course_secs is defined and (result.on_course_secs|int) > 0 %}{{ result.elapsed_time or '' }}{% else %}{% endif %}</td>
        <td class="adj-time">{{ result.adj_time or '' }}</td>
        <td>{{ comp.sailor_name }}</td>
        <td>{{ comp.boat_name }}</td>
        <td>{{ comp.sail_no }}</td>
        <td>
          <input type="number" class="form-control form-control-sm handicap-override{% if result.handicap_override is defined and result.handicap_override is not none %} text-danger{% endif %}" {% if result.handicap_override is defined and result.handicap_override is not none %}style="color: red;"{% endif %} data-cid="{{ comp.competitor_id }}" data-name="{{ comp.boat_name }}" placeholder="{{ comp.current_handicap_s_per_hr|round|int if comp.current_handicap_s_per_hr is not none else '' }}" value="{{ result.handicap_override if (result.handicap_override is defined and result.handicap_override is not none) else '' }}" disabled>
        </td>
        {% set d = (result.actual_delta if result.actual_delta is defined else None) %}
        {% set delta_class = 'delta-zero' if (d is not none and d|int == 0) else ('delta-pos' if (d is not none and d|int > 0) else ('delta-neg' if (d is not none and d|int < 0) else 'delta-zero')) %}
        <td class="actual-delta {{ delta_class }}" data-delta="{{ d if d is not none else '' }}">
          {% if d is not none %}
            {% if d|int > 0 %}
              <span class="delta"><span class="icon">â–²</span> {{ d|round|int }}</span>
            {% elif d|int < 0 %}
              <span class="delta"><span class="icon">â–¼</span> {{ d|round|int }}</span>
            {% else %}
              <span class="delta">0</span>
            {% endif %}
          {% else %}
            
          {% endif %}
        </td>
        <td class="revised-hcp">{{ result.revised_hcp|round|int if result.revised_hcp is defined and result.revised_hcp is not none else '' }}</td>
        <td class="finish-time-cell" sorttable_customkey="{{ result.finish_time or '' }}">
          <div class="input-group input-group-sm">
            <input type="text" inputmode="numeric" pattern="^\\d{1,2}(:?\\d{2})?(:?\\d{2})?$" class="form-control form-control-sm finish-time" data-cid="{{ comp.competitor_id }}" data-name="{{ comp.boat_name }}" value="{{ result.finish_time or '' }}" disabled>
            <button type="button" class="btn btn-outline-secondary btn-sm clear-time" aria-label="Clear finish time" title="Clear">&times;</button>
          </div>
        </td>
        <td class="abs-pos post-finish-col">{{ result.abs_pos|int if result.abs_pos is defined and result.abs_pos is not none else '' }}</td>
        <!-- Remaining columns in their previous relative order -->
        <td class="race-pts post-finish-col">{{ result.race_pts|round|int if result.race_pts is defined and result.race_pts is not none else '' }}</td>
        <td class="league-pts post-finish-col">{{ result.league_pts|round|int if result.league_pts is defined and result.league_pts is not none else '' }}</td>
        <td class="on-course post-finish-col">{{ result.on_course_secs|round|int if result.on_course_secs is defined and result.on_course_secs is not none else '' }}</td>
        <td class="allowance post-finish-col">{{ result.allowance|round|int if result.allowance is defined and result.allowance is not none else '' }}</td>
        <td class="full-delta post-finish-col">{{ result.full_delta|round|int if result.full_delta is defined and result.full_delta is not none else '' }}</td>
        <td class="fleet-adjustment-cell post-finish-col">{{ fleet_adjustment if fleet_adjustment is not none else '' }}</td>
      </tr>
    {% endfor %}
    </tbody>
  </table>
  </div>
  <div class="text-end mt-3">
    <button type="button" class="btn btn-danger d-none" id="deleteRace">Delete Race</button>
  </div>
<div class="modal fade" id="confirmModal" tabindex="-1">
  <div class="modal-dialog modal-dialog-centered modal-fullscreen-sm-down">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">You are about to make the following changes:</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <ul id="changeList" class="mb-0"></ul>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
        <button type="button" class="btn btn-primary" id="confirmSave">Continue</button>
      </div>
    </div>
  </div>
</div>
<!-- Invalid times info modal -->
<div class="modal fade" id="invalidModal" tabindex="-1">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Please correct time entries</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <div class="alert alert-danger" role="alert">Finish times must be after the race start time.</div>
        <ul id="invalidList" class="mb-0"></ul>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-primary" data-bs-dismiss="modal">OK</button>
      </div>
    </div>
  </div>
  </div>
<script src="{{ url_for('static', filename='sortable.js') }}"></script>
<!-- Settings update toast (preview recalculated) -->
<div class="position-fixed bottom-0 end-0 p-3" style="z-index:1080;">
  <div id="settingsToast" class="toast align-items-center text-bg-info border-0 mt-2" role="status" aria-live="polite" aria-atomic="true" data-bs-delay="2000">
    <div class="d-flex">
      <div class="toast-body">Scoring settings updated; preview recalculated.</div>
      <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
    </div>
  </div>
  </div>
<script>
document.addEventListener('DOMContentLoaded', () => {
  // Initialize client-side scorer using embedded settings and seeds
  const SCORING_SETTINGS = (window.SCORING_SETTINGS || {});
  const SCORING_VERSION = (window.SCORING_VERSION || 0);
  const PRE_RACE_SEEDS = (window.PRE_RACE_SEEDS || {});
  const scorer = new (window.Scorer && window.Scorer.Scorer ? window.Scorer.Scorer : function(){}) (SCORING_SETTINGS);
  // Expose for later steps and dev inspection
  window.CLIENT_SCORER = scorer;
  window.CLIENT_SCORING_VERSION = SCORING_VERSION;
  window.CLIENT_PRE_RACE_SEEDS = PRE_RACE_SEEDS;
  let locked = {{ 'false' if unlocked else 'true' }};
  const toggle = document.getElementById('editToggle');
  const saveBtn = document.getElementById('saveChanges');
  const cancelBtn = document.getElementById('cancelChanges');
  const seriesSelect = document.getElementById('series_id');
  const newSeriesFields = document.getElementById('new-series-fields');
  const newSeriesName = document.getElementById('new_series_name');
  const raceDate = document.getElementById('race_date');
  const startTime = document.getElementById('start_time');
  const finishInputs = Array.from(document.querySelectorAll('.finish-time'));
  const hcpInputs = Array.from(document.querySelectorAll('.handicap-override'));
  const clearTimeBtns = Array.from(document.querySelectorAll('.clear-time'));
  hcpInputs.forEach(inp => {
    inp.dataset.base = inp.placeholder;
  });
  const finisherDiv = document.getElementById('finisherCount');
  const confirmModalEl = document.getElementById('confirmModal');
  const confirmModal = new bootstrap.Modal(confirmModalEl);
  const invalidModalEl = document.getElementById('invalidModal');
  const invalidModal = new bootstrap.Modal(invalidModalEl);
  const invalidList = document.getElementById('invalidList');
  const changeList = document.getElementById('changeList');
  const confirmSave = document.getElementById('confirmSave');
  const deleteBtn = document.getElementById('deleteRace');
  const settingsToastEl = document.getElementById('settingsToast');
  const settingsToast = settingsToastEl ? new bootstrap.Toast(settingsToastEl) : null;

  let orig = {};
  let pendingAction = null;
  let fetchingScoring = null;

  // Normalize user-entered times so that:
  // - "1030"   -> 10:30:00
  // - "103045" -> 10:30:45
  // - "H:MM" or "HH:MM" -> pad and add :00 seconds
  // Returns normalized HH:MM:SS or the original trimmed string if not recognized
  function normalizeToHMS(raw) {
    if (raw == null) return '';
    let v = String(raw).trim();
    if (v === '') return '';
    // If already has colons, ensure padding and seconds
    if (v.includes(':')) {
      const parts = v.split(':').map(p => p.trim());
      if (parts.length === 2 || parts.length === 3) {
        let h = parts[0] || '0';
        let m = parts[1] || '0';
        let s = (parts.length === 3 ? (parts[2] || '0') : '0');
        // Coerce to integers and pad
        const hi = parseInt(h, 10);
        const mi = parseInt(m, 10);
        const si = parseInt(s, 10);
        if ([hi, mi, si].some(x => Number.isNaN(x))) return v; // give up, return as typed
        return `${String(hi).padStart(2, '0')}:${String(mi).padStart(2, '0')}:${String(si).padStart(2, '0')}`;
      }
      return v; // unusual format; leave as-is
    }
    // Digits-only shorthands
    if (!/^\d+$/.test(v)) return v;
    // HHMM (3-4 digits) -> seconds 00
    if (v.length === 3 || v.length === 4) {
      const mm = v.slice(-2);
      const hh = v.slice(0, -2);
      const hi = parseInt(hh, 10), mi = parseInt(mm, 10);
      if (Number.isNaN(hi) || Number.isNaN(mi)) return v;
      return `${String(hi).padStart(2, '0')}:${String(mi).padStart(2, '0')}:00`;
    }
    // HHMMSS (5-6 digits)
    if (v.length === 5 || v.length === 6) {
      const ss = v.slice(-2);
      const mm = v.slice(-4, -2);
      const hh = v.slice(0, -4);
      const hi = parseInt(hh, 10), mi = parseInt(mm, 10), si = parseInt(ss, 10);
      if ([hi, mi, si].some(x => Number.isNaN(x))) return v;
      return `${String(hi).padStart(2, '0')}:${String(mi).padStart(2, '0')}:${String(si).padStart(2, '0')}`;
    }
    // Leave other lengths untouched
    return v;
  }

  function parseTimeToSeconds(v) {
    if (!v) return null;
    const parts = String(v).split(':');
    if (parts.length < 2) return null;
    const h = parseInt(parts[0], 10);
    const m = parseInt(parts[1], 10);
    const s = parts.length > 2 ? parseInt(parts[2], 10) : 0;
    if ([h, m, s].some(n => Number.isNaN(n))) return null;
    return h * 3600 + m * 60 + s;
  }

  function validateTimesAndUpdateUI() {
    const startSecs = parseTimeToSeconds(startTime.value);
    let invalid = 0;
    const offenders = [];
    finishInputs.forEach(inp => {
      const td = inp.closest('td.finish-time-cell');
      if (!td) return;
      td.classList.remove('time-invalid');
      td.removeAttribute('title');
      const finSecs = parseTimeToSeconds(inp.value);
      if (startSecs != null && finSecs != null && finSecs <= startSecs) {
        td.classList.add('time-invalid');
        td.setAttribute('title', 'Finish times must be after the race start time');
        invalid++;
        offenders.push({ name: inp.dataset.name, value: inp.value });
      }
    });
    // Store list for the Save handler to display
    validateTimesAndUpdateUI.lastOffenders = offenders;
    return invalid > 0;
  }

  function captureOrig() {
    orig = {
      series_id: seriesSelect.value,
      series_name: seriesSelect.selectedOptions[0]?.text || '',
      new_series_name: newSeriesName.value,
      race_date: raceDate.value,
      start_time: startTime.value,
      finish_times: finishInputs.map(inp => ({cid: inp.dataset.cid, name: inp.dataset.name, value: inp.value})),
      handicap_overrides: hcpInputs.map(inp => ({cid: inp.dataset.cid, name: inp.dataset.name, value: inp.value, base: inp.dataset.base, cleared: inp.dataset.cleared || ''})),
      results: (function() {
        const map = {};
        document.querySelectorAll('tbody tr[data-cid]').forEach(tr => {
          const cid = tr.dataset.cid;
          map[cid] = {
            abs_pos: tr.querySelector('.abs-pos')?.textContent || '',
            hcp_pos: tr.querySelector('.hcp-pos')?.textContent || '',
            finish_time: tr.querySelector('.finish-time')?.value || '',
            on_course: tr.querySelector('.on-course')?.textContent || '',
            elapsed_time: tr.querySelector('.elapsed-time')?.textContent || '',
            allowance: tr.querySelector('.allowance')?.textContent || '',
            adj_time: tr.querySelector('.adj-time')?.textContent || '',
            full_delta: tr.querySelector('.full-delta')?.textContent || '',
            actual_delta: tr.querySelector('.actual-delta')?.textContent || '',
            revised_hcp: tr.querySelector('.revised-hcp')?.textContent || '',
            race_pts: tr.querySelector('.race-pts')?.textContent || '',
            league_pts: tr.querySelector('.league-pts')?.textContent || '',
            sortkey: tr.querySelector('.finish-time-cell')?.getAttribute('sorttable_customkey') || ''
          };
        });
        return map;
      })(),
      finisher_text: finisherDiv.textContent
    };
  }

  function revertValues() {
    seriesSelect.value = orig.series_id;
    newSeriesName.value = orig.new_series_name;
    raceDate.value = orig.race_date;
    startTime.value = orig.start_time;
    orig.finish_times.forEach(o => {
      const inp = finishInputs.find(i => i.dataset.cid === o.cid);
      if (inp) inp.value = o.value;
    });
    orig.handicap_overrides.forEach(o => {
      const inp = hcpInputs.find(i => i.dataset.cid === o.cid);
      if (inp) {
        inp.value = o.value;
        inp.placeholder = inp.dataset.base = o.base;
        inp.dataset.cleared = o.cleared || '';
        if (o.value) {
          inp.classList.add('text-danger');
          inp.style.color = 'red';
        } else {
          inp.classList.remove('text-danger');
          inp.style.color = '';
        }
      }
    });
    computeFinishers();
    toggleSeries();
    validateTimesAndUpdateUI();
    if (orig.results) {
      document.querySelectorAll('tbody tr[data-cid]').forEach(tr => {
        const cid = tr.dataset.cid;
        const o = orig.results[cid] || null;
        if (!o) return;
        const setText = (sel, val) => { const el = tr.querySelector(sel); if (el) el.textContent = val || ''; };
        setText('.abs-pos', o.abs_pos);
        setText('.hcp-pos', o.hcp_pos);
        const fi = tr.querySelector('.finish-time'); if (fi) fi.value = o.finish_time || '';
        const ftc = tr.querySelector('.finish-time-cell'); if (ftc) ftc.setAttribute('sorttable_customkey', o.sortkey || '');
        setText('.on-course', o.on_course);
        setText('.allowance', o.allowance);
        setText('.elapsed-time', o.elapsed_time);
        setText('.adj-time', o.adj_time);
        setText('.full-delta', o.full_delta);
        (function(){
          const td = tr.querySelector('.actual-delta');
          if (!td) return;
          // Extract numeric from stored text (may contain icon), or use data attribute
          let raw = o.actual_delta;
          if (td && (!raw || raw === '')) raw = td.dataset.delta || '';
          const n = raw === '' ? null : Number(String(raw).replace(/[^\d\-]/g, ''));
          if (n === null || Number.isNaN(n)) {
            td.classList.remove('delta-pos','delta-neg','delta-zero');
            td.classList.add('delta-zero');
            td.innerHTML = '';
            td.dataset.delta = '';
          } else {
            // Re-use preview formatter to render
            const setActualDelta = (cell, val) => {
              cell.classList.remove('delta-pos', 'delta-neg', 'delta-zero');
              cell.innerHTML = '';
              if (val === null || val === undefined || Number.isNaN(Number(val))) {
                cell.classList.add('delta-zero');
                cell.dataset.delta = '';
                return;
              }
              const num = Number(val);
              cell.dataset.delta = String(num);
              if (num > 0) {
                cell.classList.add('delta-pos');
                cell.innerHTML = `<span class="delta"><span class="icon">â–²</span> ${Math.round(num)}</span>`;
              } else if (num < 0) {
                cell.classList.add('delta-neg');
                cell.innerHTML = `<span class="delta"><span class="icon">â–¼</span> ${Math.round(num)}</span>`;
              } else {
                cell.classList.add('delta-zero');
                cell.innerHTML = `<span class="delta">0</span>`;
              }
            };
            setActualDelta(td, n);
          }
        })();
        setText('.revised-hcp', o.revised_hcp);
        setText('.race-pts', o.race_pts);
        setText('.league-pts', o.league_pts);
      });
      // Reset fleet adjustment in all rows to original text from any row
      const any = document.querySelector('tbody tr[data-cid] .fleet-adjustment-cell');
      if (any) {
        const txt = any.textContent;
        document.querySelectorAll('.fleet-adjustment-cell').forEach(td => td.textContent = txt || '');
      }
      finisherDiv.textContent = orig.finisher_text || finisherDiv.textContent;
      // No preview badge; nothing to toggle here
    }
  }

  // Per-page recalculation toast/polling removed in favor of global controller in base.html

  function hasChanges() {
    if (seriesSelect.value !== orig.series_id) return true;
    if (newSeriesName.value !== orig.new_series_name) return true;
    if (raceDate.value !== orig.race_date) return true;
    if (startTime.value !== orig.start_time) return true;
    for (const o of orig.finish_times) {
      const cur = finishInputs.find(i => i.dataset.cid === o.cid);
      if (cur && cur.value !== o.value) return true;
    }
    for (const o of orig.handicap_overrides) {
      const cur = hcpInputs.find(i => i.dataset.cid === o.cid);
      if (cur) {
        const curVal = cur.dataset.cleared === '1' ? '' : cur.value;
        if (curVal !== o.value) return true;
      }
    }
    return false;
  }

  function updateButtons() {
    const dirty = !locked && hasChanges();
    const invalid = validateTimesAndUpdateUI();
    saveBtn.classList.toggle('d-none', !dirty);
    cancelBtn.classList.toggle('d-none', !dirty);
    // Keep Save clickable; intercept click to show guidance modal when invalid
    if (dirty && invalid) {
      saveBtn.setAttribute('title', 'Finish times must be after the race start time');
    } else {
      saveBtn.removeAttribute('title');
    }
  }

  function toggleSeries() {
    if (seriesSelect.value === '__new__') {
      newSeriesFields.style.display = 'block';
    } else {
      newSeriesFields.style.display = 'none';
    }
  }

  function updateLocked() {
    [seriesSelect, newSeriesName, raceDate, startTime, ...finishInputs, ...hcpInputs].forEach(inp => inp.disabled = locked);
    clearTimeBtns.forEach(btn => {
      btn.disabled = locked;
      btn.classList.toggle('d-none', locked);
    });
    toggle.textContent = locked ? 'ðŸ”’' : 'ðŸ”“';
    updateButtons();
    deleteBtn.classList.toggle('d-none', locked);
  }

  function computeFinishers() {
    const count = finishInputs.filter(inp => inp.value.trim() !== '').length;
    finisherDiv.textContent = `Number of Finishers: ${count}`;
  }

  function listChanges() {
    const changes = [];
    if (seriesSelect.value !== orig.series_id) {
      changes.push(`Series: "${orig.series_name}" â†’ "${seriesSelect.selectedOptions[0].text}"`);
    }
    if (newSeriesName.value !== orig.new_series_name) {
      changes.push(`New Series Name: "${orig.new_series_name}" â†’ "${newSeriesName.value}"`);
    }
    if (raceDate.value !== orig.race_date) {
      changes.push(`Race Date: "${orig.race_date}" â†’ "${raceDate.value}"`);
    }
    if (startTime.value !== orig.start_time) {
      const newStartDisp = (startTime.value || '').trim() === '' ? '00:00:00' : startTime.value;
      changes.push(`Start Time: "${orig.start_time}" â†’ "${newStartDisp}"`);
    }
    orig.finish_times.forEach(o => {
      const cur = finishInputs.find(i => i.dataset.cid === o.cid);
      if (cur && cur.value !== o.value) {
        changes.push(`${o.name} finish time: "${o.value}" â†’ "${cur.value}"`);
      }
    });
    orig.handicap_overrides.forEach(o => {
      const cur = hcpInputs.find(i => i.dataset.cid === o.cid);
      if (!cur) return;
      const curVal = cur.dataset.cleared === '1' ? '' : cur.value;
      if (curVal === o.value) return;
      const oldVal = o.value || o.base;
      if (cur.dataset.cleared === '1') {
        // Always present a simple, unambiguous message when clearing
        changes.push(`${o.name} SP handicap: remove manual override`);
      } else {
        changes.push(`${o.name} SP handicap: "${oldVal}" â†’ "${cur.value}"`);
      }
    });
    return changes;
  }

  function saveChanges() {
    // Only send actual changes to reduce server-side rejections on unknown ids
    const changedFinishTimes = [];
    for (const o of orig.finish_times) {
      const cur = finishInputs.find(i => i.dataset.cid === o.cid);
      if (!cur) continue;
      if ((cur.value || '') !== (o.value || '')) {
        const cidNum = parseInt(cur.dataset.cid, 10);
        changedFinishTimes.push({ competitor_id: isNaN(cidNum) ? cur.dataset.cid : cidNum, finish_time: cur.value });
      }
    }
    const changedOverrides = [];
    for (const o of orig.handicap_overrides) {
      const cur = hcpInputs.find(i => i.dataset.cid === o.cid);
      if (!cur) continue;
      const curVal = cur.dataset.cleared === '1' ? '' : (cur.value || '');
      if ((curVal || '') !== (o.value || '')) {
        const cidNum = parseInt(cur.dataset.cid, 10);
        changedOverrides.push({ competitor_id: isNaN(cidNum) ? cur.dataset.cid : cidNum, handicap: curVal });
      }
    }
    const payload = {
      series_id: seriesSelect.value,
      new_series_name: newSeriesName.value,
      date: raceDate.value,
      start_time: (startTime.value || '').trim() === '' ? null : startTime.value,
      finish_times: changedFinishTimes,
      handicap_overrides: changedOverrides,
    };
    return fetch('{{ url_for('main.update_race', race_id=selected_race.race_id) }}', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify(payload)
    }).then(async r => {
      if (!r.ok) {
        const raw = await r.text();
        let msg = raw;
        try {
          const j = JSON.parse(raw);
          msg = j.error || j.message || raw;
        } catch (_) {}
        throw new Error(msg || `Request failed with status ${r.status}`);
      }
      return r.json();
    }).then(data => {
      finisherDiv.textContent = `Number of Finishers: ${data.finisher_count}`;
      if (data.redirect) {
        window.location = data.redirect;
      } else {
        window.location.reload();
      }
    }).catch(err => {
      alert(`Save failed: ${err.message}`);
    });
  }

  toggle.addEventListener('click', () => {
    locked = !locked;
    if (!locked) {
      captureOrig();
    }
    updateLocked();
  });

  [seriesSelect, newSeriesName, raceDate, startTime, ...finishInputs, ...hcpInputs].forEach(inp => {
    inp.addEventListener('change', () => {
      // On change, normalize any time inputs so server receives HH:MM:SS
      if (inp === startTime || inp.classList.contains('finish-time')) {
        const before = inp.value;
        const normalized = normalizeToHMS(before);
        if (normalized !== before) {
          inp.value = normalized;
          // Update sort key for a finish time cell when present
          if (inp.classList.contains('finish-time')) {
            const td = inp.closest('td.finish-time-cell');
            if (td) td.setAttribute('sorttable_customkey', normalized || '');
          }
        }
      }
      computeFinishers();
      toggleSeries();
      updateButtons();
    });
  });

  // Live validation while typing
  function liveFormatTimeInput(el, isFinish=false) {
    function fmtFromBuf(buf) {
      const b = buf.slice(0, 6);
      let h = '00', m = '00', s = '00';
      if (b.length === 0) return '00:00:00';
      if (b.length <= 2) {
        h = b.padStart(2, '0');
      } else if (b.length <= 4) {
        h = b.slice(0, 2);
        m = b.slice(2).padStart(2, '0');
      } else {
        h = b.slice(0, 2);
        m = b.slice(2, 4);
        s = b.slice(4).padStart(2, '0');
      }
      return `${h}:${m}:${s}`;
    }
    function selectSegment(bufLen) {
      try {
        if (bufLen <= 1) {
          el.setSelectionRange(0, 2);
        } else if (bufLen <= 4) {
          el.setSelectionRange(3, 5);
        } else {
          el.setSelectionRange(6, 8);
        }
      } catch (_) {}
    }
    function selectSegmentByIndex(idx, pos = 0) {
      try {
        if (idx <= 0) { el.setSelectionRange(pos === 0 ? 0 : 1, pos === 0 ? 2 : 2); }
        else if (idx === 1) { el.setSelectionRange(pos === 0 ? 3 : 4, pos === 0 ? 5 : 5); }
        else { el.setSelectionRange(pos === 0 ? 6 : 7, pos === 0 ? 8 : 8); }
      } catch (_) {}
    }
    function currentDigits() {
      const m = String(el.value || '').match(/^(\d{2}):(\d{2}):(\d{2})$/);
      if (m) return `${m[1]}${m[2]}${m[3]}`;
      const buf = el.dataset.buf || '';
      return (buf + '000000').slice(0, 6);
    }
    function setDigits(d) {
      const out = `${d.slice(0,2)}:${d.slice(2,4)}:${d.slice(4,6)}`;
      el.value = out;
      if (isFinish) {
        const td = el.closest('td.finish-time-cell');
        if (td) td.setAttribute('sorttable_customkey', out || '');
      }
      computeFinishers();
      updateButtons();
    }
    function updateFromBuf() {
      const buf = el.dataset.buf || '';
      const out = fmtFromBuf(buf);
      el.value = out;
      if (isFinish) {
        const td = el.closest('td.finish-time-cell');
        if (td) td.setAttribute('sorttable_customkey', (buf.length >= 4 ? out : ''));
      }
      computeFinishers();
      updateButtons();
    }
    el.addEventListener('focus', () => {
      if (!el.value) {
        el.dataset.buf = '';
        el.value = '00:00:00';
        try { el.setSelectionRange(0, 2); } catch (_) {}
        el.dataset.seg = '0';
        el.dataset.segpos = '0';
      } else {
        // Initialize buffer from current value
        const m = String(el.value).match(/^(\d{2}):(\d{2}):(\d{2})$/);
        if (m) {
          el.dataset.buf = `${m[1]}${m[2]}${m[3]}`.replace(/^0{2}/, m[1]);
        } else {
          el.dataset.buf = (el.value || '').replace(/\D/g, '').slice(0, 6);
        }
        selectSegment((el.dataset.buf || '').length || 1);
        el.dataset.seg = '0';
        el.dataset.segpos = '0';
      }
      // For Start Time, ensure hours are selected on first focus/click,
      // even when a full HH:MM:SS value is pre-filled.
      if (el.id === 'start_time' && !el.dataset.initHourSelectDone) {
        try {
          // Defer to run after any native click caret placement
          setTimeout(() => {
            try { el.setSelectionRange(0, 2); } catch (_) {}
            el.dataset.seg = '0';
            el.dataset.segpos = '0';
          }, 0);
        } catch (_) {}
        el.dataset.initHourSelectDone = '1';
      }
    });
    el.addEventListener('keydown', (e) => {
      if (e.key === 'Tab') return; // allow navigation
      if (e.key === 'Enter') { e.preventDefault(); el.blur(); return; }
      if (e.key === 'Escape') { e.preventDefault(); return; }
      if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
        e.preventDefault();
        let seg = parseInt(el.dataset.seg || '0', 10);
        let pos = parseInt(el.dataset.segpos || '0', 10);
        if (e.key === 'ArrowLeft') {
          if (pos === 1) { pos = 0; }
          else { seg = Math.max(0, seg - 1); pos = 0; }
        } else {
          if (pos === 0) { pos = 1; }
          else { seg = Math.max(0, Math.min(2, seg + 1)); pos = 0; }
        }
        el.dataset.seg = String(seg);
        el.dataset.segpos = String(pos);
        selectSegmentByIndex(seg, pos);
        return;
      }
      let buf = el.dataset.buf || '';
      if (e.key === 'Backspace') {
        e.preventDefault();
        if (buf.length >= 6) {
          // Clear current digit within selected segment
          let seg = parseInt(el.dataset.seg || '0', 10);
          let pos = parseInt(el.dataset.segpos || '0', 10);
          const d = currentDigits().split('');
          const idx = seg * 2 + pos;
          d[idx] = '0';
          const nd = d.join('');
          el.dataset.buf = nd; // keep at 6 to allow overwriting
          setDigits(nd);
          // Move caret left within segment or to previous segment end
          if (pos === 1) { pos = 0; }
          else { seg = Math.max(0, seg - 1); pos = 1; }
          el.dataset.seg = String(seg);
          el.dataset.segpos = String(pos);
          selectSegmentByIndex(seg, pos);
        } else {
          if (buf.length > 0) buf = buf.slice(0, -1);
          el.dataset.buf = buf;
          updateFromBuf();
          selectSegment(buf.length || 1);
        }
        return;
      }
      if (!/^[0-9]$/.test(e.key)) { e.preventDefault(); return; }
      e.preventDefault();
      if (buf.length >= 6) {
        // Overwrite current segment digit
        let seg = parseInt(el.dataset.seg || '0', 10);
        let pos = parseInt(el.dataset.segpos || '0', 10);
        const d = currentDigits().split('');
        const idx = seg * 2 + pos;
        d[idx] = e.key;
        const nd = d.join('');
        el.dataset.buf = nd;
        setDigits(nd);
        // Fire input so downstream listeners update UI and preview
        try { el.dispatchEvent(new Event('input', { bubbles: true })); } catch (_) {}
        // Advance within segment, then to next segment
        if (pos === 0) { pos = 1; }
        else { pos = 0; seg = Math.min(2, seg + 1); }
        el.dataset.seg = String(seg);
        el.dataset.segpos = String(pos);
        selectSegmentByIndex(seg, pos);
      } else {
        buf += e.key;
        el.dataset.buf = buf;
        updateFromBuf();
        selectSegment(buf.length);
        // Keep segment tracking aligned to progressive typing
        if (buf.length <= 2) { el.dataset.seg = '0'; el.dataset.segpos = String((buf.length % 2)); }
        else if (buf.length <= 4) { el.dataset.seg = '1'; el.dataset.segpos = String((buf.length - 2) % 2); }
        else { el.dataset.seg = '2'; el.dataset.segpos = String((buf.length - 4) % 2); }
        // Fire input so downstream listeners update UI and preview
        try { el.dispatchEvent(new Event('input', { bubbles: true })); } catch (_) {}
      }
    });
    el.addEventListener('blur', () => {
      // If user entered no digits while focused, leave the cell blank
      if (isFinish) {
        const buf = el.dataset.buf || '';
        if (buf.length === 0) {
          el.value = '';
          const td = el.closest('td.finish-time-cell');
          if (td) td.setAttribute('sorttable_customkey', '');
          computeFinishers();
          updateButtons();
          return;
        }
      }
      // Ensure value is normalized on blur; keep blank if cleared programmatically
      if (!el.value) return;
      const normalized = normalizeToHMS(el.value);
      el.value = normalized;
      if (isFinish) {
        const td = el.closest('td.finish-time-cell');
        if (td) td.setAttribute('sorttable_customkey', normalized || '');
      }
      computeFinishers();
      updateButtons();
    });
  }
  liveFormatTimeInput(startTime, false);
  finishInputs.forEach(inp => liveFormatTimeInput(inp, true));
  // Ensure Start Time selects hours on first mouse/touch interaction as well
  (function ensureStartHourOnFirstPointer() {
    if (!startTime) return;
    function selectHoursOnce(e) {
      if (startTime.disabled) return;
      if (startTime.dataset.pointerHourInit === '1') return;
      // Prevent native caret placement, then focus and select hours
      if (e && typeof e.preventDefault === 'function') e.preventDefault();
      if (document.activeElement !== startTime) startTime.focus();
      try { startTime.setSelectionRange(0, 2); } catch (_) {}
      startTime.dataset.seg = '0';
      startTime.dataset.segpos = '0';
      startTime.dataset.pointerHourInit = '1';
    }
    startTime.addEventListener('mousedown', selectHoursOnce, { capture: true });
    startTime.addEventListener('touchstart', selectHoursOnce, { capture: true });
  })();
  function scrollInputIntoView(input) {
    if (!input) return;
    const margin = 12;
    const wrapper = input.closest('.race-table-wrapper');
    if (wrapper && wrapper !== document.body) {
      const wrapperRect = wrapper.getBoundingClientRect();
      const inputRect = input.getBoundingClientRect();
      const hasVerticalOverflow = (wrapper.scrollHeight - wrapper.clientHeight) > 1;
      if (hasVerticalOverflow) {
        const deltaTop = inputRect.top - (wrapperRect.top + margin);
        if (deltaTop < 0) {
          wrapper.scrollTop += deltaTop;
          return;
        }
        const deltaBottom = inputRect.bottom - (wrapperRect.bottom - margin);
        if (deltaBottom > 0) {
          wrapper.scrollTop += deltaBottom;
          return;
        }
      }
      if (inputRect.left < wrapperRect.left || inputRect.right > wrapperRect.right) {
        try {
          input.scrollIntoView({ block: 'nearest', inline: 'nearest' });
        } catch (_) {
          input.scrollIntoView();
        }
      }
      if (hasVerticalOverflow) return;
    }
    const rect = input.getBoundingClientRect();
    const viewportTop = margin;
    const viewportBottom = window.innerHeight - margin;
    if (rect.top < viewportTop) {
      window.scrollBy(0, rect.top - viewportTop);
    } else if (rect.bottom > viewportBottom) {
      window.scrollBy(0, rect.bottom - viewportBottom);
    }
  }

  // Custom tab navigation: keep focus in same column, move by row
  function focusByRow(currentEl, selector, dir = 1) {
    if (!currentEl) return;
    const curRow = currentEl.closest('tr');
    if (!curRow) return;
    let targetRow = curRow;
    // dir: 1 = next row, -1 = previous row
    do {
      targetRow = (dir > 0) ? targetRow.nextElementSibling : targetRow.previousElementSibling;
    } while (targetRow && (!targetRow.matches('tr[data-cid]')));
    // Wrap around if we hit the end
    if (!targetRow) {
      const tbody = curRow.parentElement;
      if (!tbody) return;
      targetRow = (dir > 0) ? tbody.querySelector('tr[data-cid]') : Array.from(tbody.querySelectorAll('tr[data-cid]')).pop();
    }
    if (!targetRow) return;
    const targetInput = targetRow.querySelector(selector);
    if (targetInput && !targetInput.disabled) {
      targetInput.focus();
      try { if (typeof targetInput.select === 'function') targetInput.select(); } catch (_) {}
      scrollInputIntoView(targetInput);
    }
  }
  // Handle Tab/Shift+Tab on finish time inputs
  finishInputs.forEach(inp => {
    inp.addEventListener('keydown', (e) => {
      if (inp.disabled) return;
      if (e.key === 'Tab') {
        e.preventDefault();
        const dir = e.shiftKey ? -1 : 1;
        focusByRow(inp, '.finish-time', dir);
      }
    });
  });
  // Handle Tab/Shift+Tab on handicap override inputs
  hcpInputs.forEach(inp => {
    inp.addEventListener('keydown', (e) => {
      if (inp.disabled) return;
      if (e.key === 'Tab') {
        e.preventDefault();
        const dir = e.shiftKey ? -1 : 1;
        focusByRow(inp, '.handicap-override', dir);
      }
    });
  });
  startTime.addEventListener('input', () => {
    updateButtons();
    scheduleLivePreview();
    // Also update all rows' immediate on-course previews if finish present
    document.querySelectorAll('tbody tr[data-cid]').forEach(tr => immediateUpdateRow(tr));
  });
  // Normalize start time on blur and Enter
  startTime.addEventListener('blur', () => {
    if (startTime.disabled) return;
    const before = startTime.value;
    const normalized = normalizeToHMS(before);
    if (normalized !== before) startTime.value = normalized;
    updateButtons();
  });
  startTime.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      startTime.blur();
    }
  });
  finishInputs.forEach(inp => inp.addEventListener('input', (e) => {
    computeFinishers();
    updateButtons();
    const tr = e.currentTarget.closest('tr[data-cid]');
    if (tr) immediateUpdateRow(tr);
    scheduleLivePreview();
  }));
  // Normalize finish times on blur and Enter; keep sort key in sync
  finishInputs.forEach(inp => {
    inp.addEventListener('blur', () => {
      if (inp.disabled) return;
      // If no digits were entered while focused, leave blank
      const buf = inp.dataset.buf || '';
      if (buf.length === 0) {
        inp.value = '';
        const td = inp.closest('td.finish-time-cell');
        if (td) td.setAttribute('sorttable_customkey', '');
        computeFinishers();
        updateButtons();
        return;
      }
      const before = inp.value;
      const normalized = normalizeToHMS(before);
      if (normalized !== before) {
        inp.value = normalized;
        const td = inp.closest('td.finish-time-cell');
        if (td) td.setAttribute('sorttable_customkey', normalized || '');
      }
      computeFinishers();
      updateButtons();
      const tr = inp.closest('tr[data-cid]');
      if (tr) immediateUpdateRow(tr);
      scheduleLivePreview();
    });
    inp.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        inp.blur();
      }
    });
  });

  clearTimeBtns.forEach(btn => {
    btn.addEventListener('click', (e) => {
      const group = e.currentTarget.closest('.input-group');
      if (!group) return;
      const input = group.querySelector('input.finish-time, #start_time');
      if (!input || input.disabled) return;
      input.value = '';
      // Update sort key for finish rows if applicable
      const td = group.closest('td.finish-time-cell');
      if (td) td.setAttribute('sorttable_customkey', '');
      // Trigger input/change handlers to update UI state
      input.dispatchEvent(new Event('input', { bubbles: true }));
      input.dispatchEvent(new Event('change', { bubbles: true }));
      updateButtons();
      const tr = input.closest('tr[data-cid]');
      if (tr) immediateUpdateRow(tr);
      scheduleLivePreview();
    });
  });

  
  hcpInputs.forEach(inp => {
    // When focusing the input, do not inject the base value.
    // Keep it truly blank if cleared, so users see an empty field until save.
    inp.addEventListener('focus', () => {
      // Do not clear placeholder on focus; keep base visible if empty
      if (inp.dataset.cleared === '1') {
        inp.value = '';
      }
      // Select current content for quick overwrite
      try { inp.select(); } catch (_) {}
    });
    inp.addEventListener('keydown', e => {
      if (e.key === 'Enter') {
        e.preventDefault();
        inp.blur();
      }
    });
    inp.addEventListener('input', () => {
      if (inp.value === '') {
        // Mark as cleared (request to remove override) but keep field empty
        inp.dataset.cleared = '1';
        inp.classList.remove('text-danger');
        inp.style.color = '';
      } else {
        inp.dataset.cleared = '';
        inp.classList.add('text-danger');
        inp.style.color = 'red';
      }
      updateButtons();
      // Handicap change affects allowance/adj time; refresh previews
      const tr = inp.closest('tr[data-cid]');
      if (tr) immediateUpdateRow(tr);
      scheduleLivePreview();
    });
    inp.addEventListener('blur', () => {
      // On blur, if left empty, keep it visually empty and mark as cleared.
      if (inp.value === '') {
        inp.dataset.cleared = '1';
        inp.classList.remove('text-danger');
        inp.style.color = '';
        // Keep base visible as placeholder
        inp.placeholder = inp.dataset.base;
      } else {
        inp.dataset.cleared = '';
        inp.classList.add('text-danger');
        inp.style.color = 'red';
        // Show base as placeholder for consistency
        inp.placeholder = inp.dataset.base;
      }
      updateButtons();
    });
  });

  cancelBtn.addEventListener('click', () => {
    revertValues();
    locked = true;
    updateLocked();
  });

  saveBtn.addEventListener('click', async () => {
    // If invalid times exist, show info modal instead of confirm
    const invalid = validateTimesAndUpdateUI();
    if (invalid) {
      if (invalidList) {
        invalidList.innerHTML = '';
        (validateTimesAndUpdateUI.lastOffenders || []).forEach(o => {
          const li = document.createElement('li');
          li.textContent = `${o.name}: ${o.value}`;
          invalidList.appendChild(li);
        });
      }
      invalidModal.show();
      return;
    }
    // Simplified: rely on server preview fetched below; no baseline-change prompt
    const changes = listChanges();
    changeList.innerHTML = '';
    changes.forEach(ch => {
      const li = document.createElement('li');
      li.textContent = ch;
      changeList.appendChild(li);
    });
    try {
      await previewChanges();
    } catch (err) {
      alert(String(err?.message || err));
    }
    pendingAction = 'save';
    confirmModal.show();
  });

  confirmSave.addEventListener('click', () => {
    if (pendingAction === 'delete') {
      deleteRace().then(data => {
        if (data.redirect) {
          window.location = data.redirect;
        }
      });
    } else {
      // Lock immediately at the beginning of the workflow
      locked = true;
      updateLocked();
      // Prevent users from unlocking while processing
      if (toggle) toggle.disabled = true;
      // Signal global recalculation UI/polling across pages
      if (window.SignalRecalcStart) {
        try { window.SignalRecalcStart(); } catch (_) {}
      }
      // Proceed with save
      saveChanges();
    }
    confirmModal.hide();
  });

  deleteBtn.addEventListener('click', () => {
    changeList.innerHTML = '';
    const li = document.createElement('li');
    li.textContent = 'This race will be permanently deleted.';
    changeList.appendChild(li);
    pendingAction = 'delete';
    confirmModal.show();
  });

  function deleteRace() {
    return fetch('{{ url_for('main.delete_race', race_id=selected_race.race_id) }}', {
      method: 'DELETE'
    }).then(r => r.json());
  }

  computeFinishers();
  toggleSeries();
  captureOrig();
  function applyPreviewResults(payload) {
    const res = payload?.results || {};
    const setFleetAdj = (val) => {
      document.querySelectorAll('.fleet-adjustment-cell').forEach(td => td.textContent = (val ?? '') === '' ? '' : String(val));
    };
    const toRounded = (v) => {
      if (v === null || v === undefined || v === '') return '';
      const n = Number(v);
      if (Number.isNaN(n)) return String(v);
      return String(Math.round(n));
    };
    Object.keys(res).forEach(k => {
      const cid = String(k);
      const tr = document.querySelector(`tbody tr[data-cid="${cid}"]`);
      if (!tr) return;
      const r = res[k] || {};
      const setText = (sel, val) => { const el = tr.querySelector(sel); if (el) el.textContent = (val ?? '') === '' ? '' : String(val); };
      const setActualDelta = (td, val) => {
        if (!td) return;
        const n = (val === '' || val === null || val === undefined) ? null : Number(val);
        td.classList.remove('delta-pos', 'delta-neg', 'delta-zero');
        td.innerHTML = '';
        if (n === null || Number.isNaN(n)) {
          td.classList.add('delta-zero');
          td.dataset.delta = '';
          return;
        }
        td.dataset.delta = String(n);
        if (n > 0) {
          td.classList.add('delta-pos');
          td.innerHTML = `<span class="delta"><span class="icon">â–²</span> ${Math.round(n)}</span>`;
        } else if (n < 0) {
          td.classList.add('delta-neg');
          td.innerHTML = `<span class="delta"><span class="icon">â–¼</span> ${Math.round(n)}</span>`;
        } else {
          td.classList.add('delta-zero');
          td.innerHTML = `<span class="delta">0</span>`;
        }
      };
      // Positions as integers
      setText('.abs-pos', toRounded(r.abs_pos));
      setText('.hcp-pos', toRounded(r.hcp_pos));
      const fi = tr.querySelector('.finish-time');
      if (fi) {
        // Avoid clobbering the user's active typing
        if (document.activeElement !== fi) {
          fi.value = r.finish_time || '';
        }
      }
      const ftc = tr.querySelector('.finish-time-cell'); if (ftc) ftc.setAttribute('sorttable_customkey', r.finish_time || '');
      // Numeric fields rounded as per initial render
      setText('.on-course', toRounded(r.on_course_secs));
      setText('.elapsed-time', (r && Number(r.on_course_secs) > 0) ? (r.elapsed_time || '') : '');
      setText('.allowance', toRounded(r.allowance));
      setText('.adj-time', (r && Number(r.on_course_secs) > 0) ? (r.adj_time || '') : '');
      setText('.full-delta', toRounded(r.full_delta));
      setActualDelta(tr.querySelector('.actual-delta'), r.actual_delta);
      setText('.revised-hcp', toRounded(r.revised_hcp));
      setText('.race-pts', toRounded(r.race_pts));
      setText('.league-pts', toRounded(r.league_pts));
    });
    finisherDiv.textContent = `Number of Finishers: ${payload?.finisher_count ?? 0}`;
    setFleetAdj(payload?.fleet_adjustment ?? '');
    validateTimesAndUpdateUI();
  }

  async function previewChanges() {
    // Only send actual changes to minimize payload
    const changedFinishTimes = [];
    for (const o of orig.finish_times) {
      const cur = finishInputs.find(i => i.dataset.cid === o.cid);
      if (!cur) continue;
      if ((cur.value || '') !== (o.value || '')) {
        const cidNum = parseInt(cur.dataset.cid, 10);
        changedFinishTimes.push({ competitor_id: isNaN(cidNum) ? cur.dataset.cid : cidNum, finish_time: cur.value });
      }
    }
    const changedOverrides = [];
    for (const o of orig.handicap_overrides) {
      const cur = hcpInputs.find(i => i.dataset.cid === o.cid);
      if (!cur) continue;
      const curVal = cur.dataset.cleared === '1' ? '' : (cur.value || '');
      if ((curVal || '') !== (o.value || '')) {
        const cidNum = parseInt(cur.dataset.cid, 10);
        changedOverrides.push({ competitor_id: isNaN(cidNum) ? cur.dataset.cid : cidNum, handicap: curVal });
      }
    }
    const payload = {
      start_time: (startTime.value || '').trim() === '' ? null : startTime.value,
      finish_times: changedFinishTimes,
      handicap_overrides: changedOverrides,
    };
    const res = await fetch('{{ url_for('main.preview_race', race_id=selected_race.race_id) }}', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify(payload)
    });
    if (!res.ok) {
      const raw = await res.text();
      let msg = raw;
      try { const j = JSON.parse(raw); msg = j.error || j.message || raw; } catch (_) {}
      throw new Error(msg || `Preview failed with status ${res.status}`);
    }
    const data = await res.json();
    applyPreviewResults(data);
    // Preview applied; preview badge removed per UI tweak
  }

  // --- Live preview: immediate, debounced (client-side compute only) ---
  let livePreviewTimer = null;

  function buildLivePreviewPayload() {
    // Compare current inputs against original snapshot to minimize payload
    const changedFinishTimes = [];
    for (const o of orig.finish_times) {
      const cur = finishInputs.find(i => i.dataset.cid === o.cid);
      if (!cur) continue;
      const curVal = (cur.value || '').trim();
      const origVal = (o.value || '').trim();
      if (curVal !== origVal) {
        const cidNum = parseInt(cur.dataset.cid, 10);
        changedFinishTimes.push({ competitor_id: isNaN(cidNum) ? cur.dataset.cid : cidNum, finish_time: curVal });
      }
    }
    const changedOverrides = [];
    for (const o of orig.handicap_overrides) {
      const cur = hcpInputs.find(i => i.dataset.cid === o.cid);
      if (!cur) continue;
      const curVal = cur.dataset.cleared === '1' ? '' : (cur.value || '');
      const origVal = (o.value || '');
      if (curVal !== origVal) {
        const cidNum = parseInt(cur.dataset.cid, 10);
        changedOverrides.push({ competitor_id: isNaN(cidNum) ? cur.dataset.cid : cidNum, handicap: curVal });
      }
    }
    const payload = {
      finish_times: changedFinishTimes,
      handicap_overrides: changedOverrides,
    };
    // Include start_time only if changed vs. original (respecting clear)
    const curStart = (startTime.value || '').trim();
    const origStart = (orig.start_time || '').trim();
    if (curStart !== origStart) {
      payload.start_time = curStart === '' ? null : curStart;
    }
    return payload;
  }

  async function runLivePreviewNow() {
    // Do not run when locked or if invalid time ordering is detected
    if (locked) return;
    const invalid = validateTimesAndUpdateUI();
    if (invalid) return;
    // Build entries from current DOM state
    const scorer = window.CLIENT_SCORER;
    if (!scorer || typeof scorer.calculateRaceResults !== 'function') return;
    const startRaw = (startTime.value || '').trim();
    const startNorm = startRaw ? normalizeToHMS(startRaw) : '';
    let startSecs = 0;
    try { startSecs = startNorm ? parseHMS(startNorm) : 0; } catch (_) { startSecs = 0; }

    const seeds = window.CLIENT_PRE_RACE_SEEDS || {};
    const rows = Array.from(document.querySelectorAll('tbody tr[data-cid]'));
    const entries = [];
    let finisherCount = 0;
    const currentFinishStr = {};
    const currentOverride = {};
    for (const tr of rows) {
      const cid = parseInt(tr.dataset.cid, 10);
      if (!Number.isFinite(cid)) continue;
      const hcpInput = tr.querySelector('.handicap-override');
      let override = null;
      if (hcpInput) {
        const raw = (hcpInput.value || '').trim();
        if (raw !== '' && hcpInput.dataset.cleared !== '1') {
          const num = Number(raw);
          if (!Number.isNaN(num)) override = num;
        }
      }
      currentOverride[cid] = override;
      let initial = (override !== null && override !== undefined) ? Number(override) : undefined;
      if (initial === undefined) {
        const seed = seeds && Object.prototype.hasOwnProperty.call(seeds, cid) ? Number(seeds[cid]) : undefined;
        if (seed !== undefined && !Number.isNaN(seed)) initial = seed;
      }
      if (initial === undefined) {
        // Fallback to placeholder/base if available
        const baseStr = hcpInput ? (hcpInput.placeholder || '') : '';
        const base = baseStr === '' ? undefined : Number(baseStr);
        if (base !== undefined && !Number.isNaN(base)) initial = base;
      }
      if (initial === undefined) continue; // skip rows we cannot seed

      const finInput = tr.querySelector('.finish-time');
      const finRaw = finInput ? (finInput.value || '').trim() : '';
      currentFinishStr[cid] = finRaw;
      let finSecs = null;
      if (finRaw !== '') {
        try { finSecs = parseHMS(normalizeToHMS(finRaw)); } catch (_) { finSecs = null; }
      }
      const entry = { competitor_id: cid, start: startSecs, initial_handicap: Number(initial) };
      if (finSecs != null && finSecs > startSecs) { entry.finish = finSecs; finisherCount += 1; }
      entries.push(entry);
    }

    const resultsList = scorer.calculateRaceResults(entries) || [];
    // Build response-like payload to reuse DOM updater
    const results = {};
    for (const r of resultsList) {
      const cid = Number(r.competitor_id);
      const isNonFinisher = !(Object.prototype.hasOwnProperty.call(r, 'finish') && r.finish != null);
      const elapsed = r.elapsed_seconds;
      results[cid] = {
        finish_time: currentFinishStr[cid] || '',
        on_course_secs: elapsed,
        elapsed_time: (elapsed && elapsed > 0) ? secondsToHMS(elapsed) : '',
        abs_pos: r.absolute_position,
        allowance: r.allowance_seconds,
        adj_time_secs: r.adjusted_time_seconds,
        adj_time: (!isNonFinisher ? secondsToHMS(r.adjusted_time_seconds) : null),
        hcp_pos: r.handicap_position,
        race_pts: r.traditional_points,
        league_pts: r.points,
        full_delta: r.full_delta,
        scaled_delta: r.scaled_delta,
        actual_delta: r.actual_delta,
        revised_hcp: r.revised_handicap != null ? r.revised_handicap : (r.initial_handicap != null ? r.initial_handicap : null),
        place: r.status,
        handicap_override: currentOverride[cid],
      };
    }
    const fleetAdj = finisherCount ? Math.round((scorer.scalingFactor(finisherCount) || 0) * 100) : 0;
    applyPreviewResults({ results, finisher_count: finisherCount, fleet_adjustment: fleetAdj });
  }

  function scheduleLivePreview() {
    if (livePreviewTimer) {
      clearTimeout(livePreviewTimer);
      livePreviewTimer = null;
    }
    // Small debounce to coalesce keystrokes while keeping UI snappy
    livePreviewTimer = setTimeout(runLivePreviewNow, 80);
  }

  // Immediate local row updates for feel (on-course, elapsed, allowance, adj time)
  function secondsToHMS(totalSeconds) {
    const t = Math.round(Number(totalSeconds) || 0);
    const h = Math.floor(t / 3600).toString().padStart(2, '0');
    const m = Math.floor((t % 3600) / 60).toString().padStart(2, '0');
    const s = Math.floor(t % 60).toString().padStart(2, '0');
    return `${h}:${m}:${s}`;
  }
  function parseHMS(v) {
    if (!v) return null;
    const parts = String(v).split(':');
    if (parts.length !== 3) return null;
    const [h,m,s] = parts.map(x => parseInt(x, 10));
    if ([h,m,s].some(n => Number.isNaN(n))) return null;
    return h*3600 + m*60 + s;
  }
  function immediateUpdateRow(tr) {
    try {
      const fin = tr.querySelector('.finish-time');
      if (!fin) return;
      const finS = parseHMS(fin.value);
      const startS = parseHMS(startTime.value || '00:00:00') || 0;
      if (finS == null || finS <= startS) {
        // Clear immediate previews when invalid or blank
        const clear = sel => { const el = tr.querySelector(sel); if (el) el.textContent = ''; };
        clear('.on-course');
        clear('.elapsed-time');
        clear('.allowance');
        clear('.adj-time');
        return;
      }
      const hcpInput = tr.querySelector('.handicap-override');
      const base = (hcpInput && hcpInput.value !== '' && hcpInput.dataset.cleared !== '1') ? Number(hcpInput.value) : Number(hcpInput?.placeholder || 0);
      const onCourse = finS - startS;
      const allowance = (base || 0) * (onCourse / 3600);
      const adj = onCourse - allowance;
      const setText = (sel, val) => { const el = tr.querySelector(sel); if (el) el.textContent = String(Math.round(val)); };
      const setHMS = (sel, val) => { const el = tr.querySelector(sel); if (el) el.textContent = secondsToHMS(val); };
      setText('.on-course', onCourse);
      setHMS('.elapsed-time', onCourse);
      setText('.allowance', allowance);
      setHMS('.adj-time', adj);
    } catch (_) {}
  }
  updateLocked();
  // Global controller in base.html will handle any background recalc state on load
});
</script>
{% endif %}
{% endblock %}
  async function fetchScoringSettings(full = true) {
    if (fetchingScoring) { try { await fetchingScoring; } catch (_) {} }
    const url = full ? '/api/settings/scoring' : '/api/settings/scoring?only=version';
    fetchingScoring = fetch(url).then(r => r.json()).catch(() => null);
    const data = await fetchingScoring; fetchingScoring = null;
    return data;
  }

  async function applyNewScoringSettingsIfChanged(newVersion) {
    const curVersion = Number(window.CLIENT_SCORING_VERSION || 0);
    const incoming = Number(newVersion);
    if (!Number.isFinite(incoming)) return false;
    if (incoming === curVersion) return false;
    const full = await fetchScoringSettings(true);
    if (!full || typeof full.version === 'undefined') return false;
    // Re-init scorer
    window.SCORING_SETTINGS = full;
    window.SCORING_VERSION = Number(full.version) || 0;
    window.CLIENT_SCORER = new (window.Scorer && window.Scorer.Scorer ? window.Scorer.Scorer : function(){}) (full);
    window.CLIENT_SCORING_VERSION = window.SCORING_VERSION;
    // Trigger a recompute using whatever mechanism is present
    if (typeof runLivePreviewNow === 'function') {
      try { await runLivePreviewNow(); } catch (_) {}
    } else if (typeof previewChanges === 'function') {
      try { await previewChanges(); } catch (_) {}
    }
    if (settingsToast) settingsToast.show();
    return true;
  }

  // React to settings changes across tabs via localStorage
  window.addEventListener('storage', (e) => {
    if (e && e.key === 'scoringSettingsVersion' && e.newValue) {
      const v = Number(e.newValue);
      applyNewScoringSettingsIfChanged(v);
    }
  });

  // Check on visibility gain for long-lived tabs
  document.addEventListener('visibilitychange', async () => {
    if (document.visibilityState !== 'visible') return;
    const data = await fetchScoringSettings(false);
    if (data && typeof data.version !== 'undefined') {
      await applyNewScoringSettingsIfChanged(Number(data.version));
    }
  });
