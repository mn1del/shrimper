{% extends 'base.html' %}

{% block content %}
{% if selected_race %}
<div class="d-flex align-items-center mb-3">
  <a href="{{ url_for('main.races') }}">Races</a>
  <select class="form-select w-auto ms-2" onchange="window.location=this.value">
    {% for race in all_races %}
      <option value="{{ url_for('main.race_sheet', race_id=race.race_id) }}" {% if race.race_id == selected_race.race_id %}selected{% endif %}>{{ race.date }} {{ race.start_time or '' }} ({{ race.series_name }})</option>
    {% endfor %}
  </select>
</div>
<div class="d-flex justify-content-end mb-2 align-items-center">
  <button type="button" class="btn btn-success me-2 d-none" id="saveChanges">Save Changes</button>
  <button type="button" class="btn btn-danger me-2 d-none" id="cancelChanges">Cancel Changes</button>
  <button type="button" class="btn btn-outline-secondary" id="editToggle">ðŸ”’</button>
</div>
<div class="card mb-3">
  <div class="card-body">
    {% if errors %}
    <div class="alert alert-danger" role="alert">
      <div class="fw-bold mb-1">Cannot calculate results due to the following issues:</div>
      <ul class="mb-0">
        {% for e in errors %}
          <li>{{ e }}</li>
        {% endfor %}
      </ul>
    </div>
    {% endif %}
    <div class="row mb-3">
      <label class="col-md-3 col-form-label">Series</label>
      <div class="col-md-9">
        <select class="form-select" id="series_id" disabled>
          {% for s in series_list %}
            <option value="{{ s.series_id }}" {% if series.series_id == s.series_id %}selected{% endif %}>{{ s.name }}</option>
          {% endfor %}
          <option value="__new__">Create New Series</option>
        </select>
      </div>
    </div>
    <div id="new-series-fields" style="display:none;">
      <div class="row mb-3">
        <label class="col-md-3 col-form-label">Series Name</label>
        <div class="col-md-9">
          <input type="text" id="new_series_name" class="form-control" disabled>
        </div>
      </div>
    </div>
    <div class="row mb-3">
      <label class="col-md-3 col-form-label">Race Date</label>
      <div class="col-md-9">
        <input type="date" id="race_date" class="form-control" value="{{ selected_race.date }}" disabled>
      </div>
    </div>
    <div class="row mb-3">
      <label for="start_time" class="col-md-3 col-form-label">Start Time</label>
      <div class="col-md-9">
        <div class="input-group">
          <input type="time" id="start_time" step="1" class="form-control" value="{{ selected_race.start_time or '' }}" disabled>
          <button type="button" class="btn btn-outline-secondary clear-time" aria-label="Clear start time" title="Clear" >&times;</button>
        </div>
      </div>
    </div>
    <div class="row mb-3">
      <label class="col-md-3 col-form-label">Finishers</label>
      <div class="col-md-9">
        <div id="finisherCount">{{ finisher_display }}</div>
      </div>
    </div>
  </div>
</div>
{% else %}
<h1>{{ series.name }}</h1>
<form method="get" class="mb-3">
  <select name="race_id" class="form-select" onchange="this.form.submit()">
    <option value="">Select a race</option>
    {% for race in races %}
      <option value="{{ race.race_id }}">{{ race.name }} ({{ race.date }})</option>
    {% endfor %}
    <option value="__new__">Create New Race</option>
  </select>
</form>
{% endif %}

{% if selected_race %}
<style>
  .race-table-wrapper {
    max-height: 600px; /* roughly 15 rows */
    overflow-y: auto;
  }
  .race-table-wrapper thead th {
    position: sticky;
    top: 0;
    z-index: 1;
    background-color: #f8f9fa;
    white-space: normal;
  }
  .race-table-wrapper tbody td {
    white-space: nowrap;
  }
  #confirmModal .modal-content {
    display: flex;
    flex-direction: column;
    height: 100%;
  }
  #confirmModal .modal-body {
    overflow-y: auto;
  }
  @media (max-width: 576px) {
    #confirmModal .modal-dialog {
      margin: 0;
      height: 100%;
      display: flex;
      align-items: flex-end;
    }
    #confirmModal.fade .modal-dialog {
      transition: transform .3s ease-out;
      transform: translateY(100%);
    }
    #confirmModal.show .modal-dialog {
      transform: translateY(0);
    }
    #confirmModal .modal-content {
      border-radius: 0;
    }
  }
  /* Ensure Hcp input fits at least 5 characters */
  .handicap-override {
    min-width: 8ch;
  }
</style>

<div class="table-responsive race-table-wrapper">
  <table class="table table-bordered table-sm align-middle sortable">
    <thead class="table-light">
      <tr>
        <th style="width: 60px;">Abs Pos</th>
        <th style="width: 60px;">Hcp Pos</th>
        <th style="width: 150px;">Sailor</th>
        <th style="width: 150px;">Boat</th>
        <th style="width: 80px;">Sail No.</th>
        <th style="width: 110px;">Hcp (s/hr)</th>
        <th style="width: 120px;">Finish Time (hh:mm:ss)</th>
        <th style="width: 110px;">On Course Time (s)</th>
        <th style="width: 110px;">Hcp Allowance (s)</th>
        <th style="width: 120px;">Adj Time (hh:mm:ss)</th>
        <th style="width: 120px;">Full Hcp Change (s/hr)</th>
        <th style="width: 120px;">Fleet Adjustment (%)</th>
        <th style="width: 140px;">Adjusted Hcp Change (s/hr)</th>
        <th style="width: 110px;">Revised Hcp (s/hr)</th>
        <th style="width: 90px;">Race Pts (Traditional)</th>
        <th style="width: 100px;">League Pts (Adjusted)</th>
      </tr>
    </thead>
    <tbody>
    {% for comp in fleet %}
      {% set result = (selected_race.results or {}).get(comp.competitor_id, {}) %}
      <tr data-cid="{{ comp.competitor_id }}">
        <td class="abs-pos">{{ result.abs_pos|int if result.abs_pos is defined and result.abs_pos is not none else '' }}</td>
        <td class="hcp-pos">{{ result.hcp_pos|int if result.hcp_pos is defined and result.hcp_pos is not none else '' }}</td>
        <td>{{ comp.sailor_name }}</td>
        <td>{{ comp.boat_name }}</td>
        <td>{{ comp.sail_no }}</td>
        <td>
          <input type="number" class="form-control form-control-sm handicap-override{% if result.handicap_override is defined and result.handicap_override is not none %} text-danger{% endif %}" {% if result.handicap_override is defined and result.handicap_override is not none %}style="color: red;"{% endif %} data-cid="{{ comp.competitor_id }}" data-name="{{ comp.sailor_name }}" placeholder="{{ comp.current_handicap_s_per_hr|round|int if comp.current_handicap_s_per_hr is not none else '' }}" value="{{ result.handicap_override|int if (result.handicap_override is defined and result.handicap_override is not none) else '' }}" disabled>
        </td>
        <td class="finish-time-cell" sorttable_customkey="{{ result.finish_time or '' }}">
          <div class="input-group input-group-sm">
            <input type="time" step="1" class="form-control form-control-sm finish-time" data-cid="{{ comp.competitor_id }}" data-name="{{ comp.sailor_name }}" value="{{ result.finish_time or '' }}" disabled>
            <button type="button" class="btn btn-outline-secondary btn-sm clear-time" aria-label="Clear finish time" title="Clear">&times;</button>
          </div>
        </td>
        <td class="on-course">{{ result.on_course_secs|round|int if result.on_course_secs is defined and result.on_course_secs is not none else '' }}</td>
        <td class="allowance">{{ result.allowance|round|int if result.allowance is defined and result.allowance is not none else '' }}</td>
        <td class="adj-time">{{ result.adj_time or '' }}</td>
        <td class="full-delta">{{ result.full_delta|round|int if result.full_delta is defined and result.full_delta is not none else '' }}</td>
        <td class="fleet-adjustment-cell">{{ fleet_adjustment if fleet_adjustment is not none else '' }}</td>
        <td class="actual-delta">{{ result.actual_delta|round|int if result.actual_delta is defined and result.actual_delta is not none else '' }}</td>
        <td class="revised-hcp">{{ result.revised_hcp|round|int if result.revised_hcp is defined and result.revised_hcp is not none else '' }}</td>
        <td class="race-pts">{{ result.race_pts|round|int if result.race_pts is defined and result.race_pts is not none else '' }}</td>
        <td class="league-pts">{{ result.league_pts|round|int if result.league_pts is defined and result.league_pts is not none else '' }}</td>
      </tr>
    {% endfor %}
    </tbody>
  </table>
  </div>
  <div class="text-end mt-3">
    <button type="button" class="btn btn-danger d-none" id="deleteRace">Delete Race</button>
  </div>
<div class="modal fade" id="confirmModal" tabindex="-1">
  <div class="modal-dialog modal-dialog-centered modal-fullscreen-sm-down">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">You are about to make the following changes:</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <ul id="changeList" class="mb-0"></ul>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
        <button type="button" class="btn btn-primary" id="confirmSave">Continue</button>
      </div>
    </div>
  </div>
</div>
<script src="{{ url_for('static', filename='sortable.js') }}"></script>
<!-- Background recalculation toast -->
<div class="position-fixed bottom-0 end-0 p-3" style="z-index:1080;">
  <div id="recalcToast" class="toast align-items-center text-bg-secondary border-0" role="status" aria-live="polite" aria-atomic="true" data-bs-autohide="false">
    <div class="d-flex">
      <div class="toast-body">Background recalculation in progressâ€¦</div>
      <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
    </div>
  </div>
  </div>
<script>
document.addEventListener('DOMContentLoaded', () => {
  let locked = {{ 'false' if unlocked else 'true' }};
  const toggle = document.getElementById('editToggle');
  const saveBtn = document.getElementById('saveChanges');
  const cancelBtn = document.getElementById('cancelChanges');
  const seriesSelect = document.getElementById('series_id');
  const newSeriesFields = document.getElementById('new-series-fields');
  const newSeriesName = document.getElementById('new_series_name');
  const raceDate = document.getElementById('race_date');
  const startTime = document.getElementById('start_time');
  const finishInputs = Array.from(document.querySelectorAll('.finish-time'));
  const hcpInputs = Array.from(document.querySelectorAll('.handicap-override'));
  const clearTimeBtns = Array.from(document.querySelectorAll('.clear-time'));
  hcpInputs.forEach(inp => {
    inp.dataset.base = inp.placeholder;
  });
  const finisherDiv = document.getElementById('finisherCount');
  const confirmModalEl = document.getElementById('confirmModal');
  const confirmModal = new bootstrap.Modal(confirmModalEl);
  const changeList = document.getElementById('changeList');
  const confirmSave = document.getElementById('confirmSave');
  const deleteBtn = document.getElementById('deleteRace');
  const recalcToastEl = document.getElementById('recalcToast');
  const recalcToast = recalcToastEl ? new bootstrap.Toast(recalcToastEl) : null;

  let orig = {};
  let pendingAction = null;
  let recalcPoll = null;

  function captureOrig() {
    orig = {
      series_id: seriesSelect.value,
      series_name: seriesSelect.selectedOptions[0]?.text || '',
      new_series_name: newSeriesName.value,
      race_date: raceDate.value,
      start_time: startTime.value,
      finish_times: finishInputs.map(inp => ({cid: inp.dataset.cid, name: inp.dataset.name, value: inp.value})),
      handicap_overrides: hcpInputs.map(inp => ({cid: inp.dataset.cid, name: inp.dataset.name, value: inp.value, base: inp.dataset.base, cleared: inp.dataset.cleared || ''})),
      results: (function() {
        const map = {};
        document.querySelectorAll('tbody tr[data-cid]').forEach(tr => {
          const cid = tr.dataset.cid;
          map[cid] = {
            abs_pos: tr.querySelector('.abs-pos')?.textContent || '',
            hcp_pos: tr.querySelector('.hcp-pos')?.textContent || '',
            finish_time: tr.querySelector('.finish-time')?.value || '',
            on_course: tr.querySelector('.on-course')?.textContent || '',
            allowance: tr.querySelector('.allowance')?.textContent || '',
            adj_time: tr.querySelector('.adj-time')?.textContent || '',
            full_delta: tr.querySelector('.full-delta')?.textContent || '',
            actual_delta: tr.querySelector('.actual-delta')?.textContent || '',
            revised_hcp: tr.querySelector('.revised-hcp')?.textContent || '',
            race_pts: tr.querySelector('.race-pts')?.textContent || '',
            league_pts: tr.querySelector('.league-pts')?.textContent || '',
            sortkey: tr.querySelector('.finish-time-cell')?.getAttribute('sorttable_customkey') || ''
          };
        });
        return map;
      })(),
      finisher_text: finisherDiv.textContent
    };
  }

  function revertValues() {
    seriesSelect.value = orig.series_id;
    newSeriesName.value = orig.new_series_name;
    raceDate.value = orig.race_date;
    startTime.value = orig.start_time;
    orig.finish_times.forEach(o => {
      const inp = finishInputs.find(i => i.dataset.cid === o.cid);
      if (inp) inp.value = o.value;
    });
    orig.handicap_overrides.forEach(o => {
      const inp = hcpInputs.find(i => i.dataset.cid === o.cid);
      if (inp) {
        inp.value = o.value;
        inp.placeholder = inp.dataset.base = o.base;
        inp.dataset.cleared = o.cleared || '';
        if (o.value) {
          inp.classList.add('text-danger');
          inp.style.color = 'red';
        } else {
          inp.classList.remove('text-danger');
          inp.style.color = '';
        }
      }
    });
    computeFinishers();
    toggleSeries();
    if (orig.results) {
      document.querySelectorAll('tbody tr[data-cid]').forEach(tr => {
        const cid = tr.dataset.cid;
        const o = orig.results[cid] || null;
        if (!o) return;
        const setText = (sel, val) => { const el = tr.querySelector(sel); if (el) el.textContent = val || ''; };
        setText('.abs-pos', o.abs_pos);
        setText('.hcp-pos', o.hcp_pos);
        const fi = tr.querySelector('.finish-time'); if (fi) fi.value = o.finish_time || '';
        const ftc = tr.querySelector('.finish-time-cell'); if (ftc) ftc.setAttribute('sorttable_customkey', o.sortkey || '');
        setText('.on-course', o.on_course);
        setText('.allowance', o.allowance);
        setText('.adj-time', o.adj_time);
        setText('.full-delta', o.full_delta);
        setText('.actual-delta', o.actual_delta);
        setText('.revised-hcp', o.revised_hcp);
        setText('.race-pts', o.race_pts);
        setText('.league-pts', o.league_pts);
      });
      // Reset fleet adjustment in all rows to original text from any row
      const any = document.querySelector('tbody tr[data-cid] .fleet-adjustment-cell');
      if (any) {
        const txt = any.textContent;
        document.querySelectorAll('.fleet-adjustment-cell').forEach(td => td.textContent = txt || '');
      }
      finisherDiv.textContent = orig.finisher_text || finisherDiv.textContent;
      // No preview badge; nothing to toggle here
    }
  }

  async function checkRecalcOnce() {
    try {
      // Use literal path to avoid BuildError if endpoint name not registered
      const url = new URL('/api/recalc/status', window.location.origin);
      url.searchParams.set('race_id', '{{ selected_race.race_id }}');
      const res = await fetch(url.toString());
      const data = await res.json();
      const active = !!data?.in_progress;
      if (active) {
        if (recalcToast && !recalcToastEl.classList.contains('show')) recalcToast.show();
      } else {
        if (recalcToast && recalcToastEl.classList.contains('show')) recalcToast.hide();
      }
      return active;
    } catch (_) {
      return false;
    }
  }

  function startRecalcPolling() {
    if (!recalcToast) return;
    if (recalcPoll) return;
    recalcPoll = setInterval(async () => {
      const active = await checkRecalcOnce();
      if (!active) {
        clearInterval(recalcPoll);
        recalcPoll = null;
      }
    }, 1500);
  }

  function hasChanges() {
    if (seriesSelect.value !== orig.series_id) return true;
    if (newSeriesName.value !== orig.new_series_name) return true;
    if (raceDate.value !== orig.race_date) return true;
    if (startTime.value !== orig.start_time) return true;
    for (const o of orig.finish_times) {
      const cur = finishInputs.find(i => i.dataset.cid === o.cid);
      if (cur && cur.value !== o.value) return true;
    }
    for (const o of orig.handicap_overrides) {
      const cur = hcpInputs.find(i => i.dataset.cid === o.cid);
      if (cur) {
        const curVal = cur.dataset.cleared === '1' ? '' : cur.value;
        if (curVal !== o.value) return true;
      }
    }
    return false;
  }

  function updateButtons() {
    const dirty = !locked && hasChanges();
    saveBtn.classList.toggle('d-none', !dirty);
    cancelBtn.classList.toggle('d-none', !dirty);
  }

  function toggleSeries() {
    if (seriesSelect.value === '__new__') {
      newSeriesFields.style.display = 'block';
    } else {
      newSeriesFields.style.display = 'none';
    }
  }

  function updateLocked() {
    [seriesSelect, newSeriesName, raceDate, startTime, ...finishInputs, ...hcpInputs].forEach(inp => inp.disabled = locked);
    clearTimeBtns.forEach(btn => btn.disabled = locked);
    toggle.textContent = locked ? 'ðŸ”’' : 'ðŸ”“';
    updateButtons();
    deleteBtn.classList.toggle('d-none', locked);
  }

  function computeFinishers() {
    const count = finishInputs.filter(inp => inp.value.trim() !== '').length;
    finisherDiv.textContent = `Number of Finishers: ${count}`;
  }

  function listChanges() {
    const changes = [];
    if (seriesSelect.value !== orig.series_id) {
      changes.push(`Series: "${orig.series_name}" â†’ "${seriesSelect.selectedOptions[0].text}"`);
    }
    if (newSeriesName.value !== orig.new_series_name) {
      changes.push(`New Series Name: "${orig.new_series_name}" â†’ "${newSeriesName.value}"`);
    }
    if (raceDate.value !== orig.race_date) {
      changes.push(`Race Date: "${orig.race_date}" â†’ "${raceDate.value}"`);
    }
    if (startTime.value !== orig.start_time) {
      changes.push(`Start Time: "${orig.start_time}" â†’ "${startTime.value}"`);
    }
    orig.finish_times.forEach(o => {
      const cur = finishInputs.find(i => i.dataset.cid === o.cid);
      if (cur && cur.value !== o.value) {
        changes.push(`${o.name} finish time: "${o.value}" â†’ "${cur.value}"`);
      }
    });
    orig.handicap_overrides.forEach(o => {
      const cur = hcpInputs.find(i => i.dataset.cid === o.cid);
      if (cur) {
        const curVal = cur.dataset.cleared === '1' ? '' : cur.value;
        if (curVal !== o.value) {
          const oldVal = o.value || o.base;
          const newVal = cur.dataset.cleared === '1' ? cur.dataset.base : cur.value;
          changes.push(`${o.name} SP handicap: "${oldVal}" â†’ "${newVal}"`);
        }
      }
    });
    return changes;
  }

  function saveChanges() {
    // Only send actual changes to reduce server-side rejections on unknown ids
    const changedFinishTimes = [];
    for (const o of orig.finish_times) {
      const cur = finishInputs.find(i => i.dataset.cid === o.cid);
      if (!cur) continue;
      if ((cur.value || '') !== (o.value || '')) {
        const cidNum = parseInt(cur.dataset.cid, 10);
        changedFinishTimes.push({ competitor_id: isNaN(cidNum) ? cur.dataset.cid : cidNum, finish_time: cur.value });
      }
    }
    const changedOverrides = [];
    for (const o of orig.handicap_overrides) {
      const cur = hcpInputs.find(i => i.dataset.cid === o.cid);
      if (!cur) continue;
      const curVal = cur.dataset.cleared === '1' ? '' : (cur.value || '');
      if ((curVal || '') !== (o.value || '')) {
        const cidNum = parseInt(cur.dataset.cid, 10);
        changedOverrides.push({ competitor_id: isNaN(cidNum) ? cur.dataset.cid : cidNum, handicap: curVal });
      }
    }
    const payload = {
      series_id: seriesSelect.value,
      new_series_name: newSeriesName.value,
      date: raceDate.value,
      start_time: (startTime.value || '').trim() === '' ? null : startTime.value,
      finish_times: changedFinishTimes,
      handicap_overrides: changedOverrides,
    };
    return fetch('{{ url_for('main.update_race', race_id=selected_race.race_id) }}', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify(payload)
    }).then(async r => {
      if (!r.ok) {
        const raw = await r.text();
        let msg = raw;
        try {
          const j = JSON.parse(raw);
          msg = j.error || j.message || raw;
        } catch (_) {}
        throw new Error(msg || `Request failed with status ${r.status}`);
      }
      return r.json();
    }).then(data => {
      finisherDiv.textContent = `Number of Finishers: ${data.finisher_count}`;
      if (data.redirect) {
        window.location = data.redirect;
      } else {
        window.location.reload();
      }
    }).catch(err => {
      alert(`Save failed: ${err.message}`);
    });
  }

  toggle.addEventListener('click', () => {
    locked = !locked;
    if (!locked) {
      captureOrig();
    }
    updateLocked();
  });

  [seriesSelect, newSeriesName, raceDate, startTime, ...finishInputs, ...hcpInputs].forEach(inp => {
    inp.addEventListener('change', () => {
      computeFinishers();
      toggleSeries();
      updateButtons();
    });
  });

  clearTimeBtns.forEach(btn => {
    btn.addEventListener('click', (e) => {
      const group = e.currentTarget.closest('.input-group');
      if (!group) return;
      const input = group.querySelector('input[type="time"]');
      if (!input || input.disabled) return;
      input.value = '';
      // Update sort key for finish rows if applicable
      const td = group.closest('td.finish-time-cell');
      if (td) td.setAttribute('sorttable_customkey', '');
      // Trigger input/change handlers to update UI state
      input.dispatchEvent(new Event('input', { bubbles: true }));
      input.dispatchEvent(new Event('change', { bubbles: true }));
      updateButtons();
    });
  });

  finishInputs.forEach(inp => inp.addEventListener('input', () => {
    computeFinishers();
    updateButtons();
  }));
  hcpInputs.forEach(inp => {
    inp.addEventListener('focus', () => {
      inp.placeholder = '';
      if (inp.dataset.cleared === '1') {
        inp.value = '';
      } else if (inp.value === '') {
        inp.value = inp.dataset.base;
        inp.dataset.fromPlaceholder = '1';
      }
      inp.select();
    });
    inp.addEventListener('keydown', e => {
      if (e.key === 'Enter') {
        e.preventDefault();
        inp.blur();
      }
    });
    inp.addEventListener('input', () => {
      if (inp.value === '') {
        inp.dataset.cleared = '1';
        inp.classList.remove('text-danger');
        inp.style.color = '';
      } else {
        inp.dataset.cleared = '';
        inp.classList.add('text-danger');
        inp.style.color = 'red';
      }
      updateButtons();
    });
    inp.addEventListener('blur', () => {
      if (inp.dataset.fromPlaceholder === '1') {
        if (inp.value === inp.dataset.base) {
          inp.value = '';
        }
        inp.dataset.fromPlaceholder = '';
      }
      if (inp.value === '') {
        inp.value = inp.dataset.base;
        inp.dataset.cleared = '1';
        inp.classList.remove('text-danger');
        inp.style.color = '';
      } else {
        inp.dataset.cleared = '';
        inp.classList.add('text-danger');
        inp.style.color = 'red';
      }
      inp.placeholder = inp.dataset.base;
      updateButtons();
    });
  });

  cancelBtn.addEventListener('click', () => {
    revertValues();
    locked = true;
    updateLocked();
  });

  saveBtn.addEventListener('click', async () => {
    const changes = listChanges();
    changeList.innerHTML = '';
    changes.forEach(ch => {
      const li = document.createElement('li');
      li.textContent = ch;
      changeList.appendChild(li);
    });
    try {
      await previewChanges();
    } catch (err) {
      alert(String(err?.message || err));
    }
    pendingAction = 'save';
    confirmModal.show();
  });

  confirmSave.addEventListener('click', () => {
    if (pendingAction === 'delete') {
      deleteRace().then(data => {
        if (data.redirect) {
          window.location = data.redirect;
        }
      });
    } else {
      // Lock immediately at the beginning of the workflow
      locked = true;
      updateLocked();
      // Prevent users from unlocking while processing
      if (toggle) toggle.disabled = true;
      // Show recalculation feedback right away
      if (recalcToast) recalcToast.show();
      startRecalcPolling();
      // Proceed with save
      saveChanges();
    }
    confirmModal.hide();
  });

  deleteBtn.addEventListener('click', () => {
    changeList.innerHTML = '';
    const li = document.createElement('li');
    li.textContent = 'This race will be permanently deleted.';
    changeList.appendChild(li);
    pendingAction = 'delete';
    confirmModal.show();
  });

  function deleteRace() {
    return fetch('{{ url_for('main.delete_race', race_id=selected_race.race_id) }}', {
      method: 'DELETE'
    }).then(r => r.json());
  }

  computeFinishers();
  toggleSeries();
  captureOrig();
  function applyPreviewResults(payload) {
    const res = payload?.results || {};
    const setFleetAdj = (val) => {
      document.querySelectorAll('.fleet-adjustment-cell').forEach(td => td.textContent = (val ?? '') === '' ? '' : String(val));
    };
    Object.keys(res).forEach(k => {
      const cid = String(k);
      const tr = document.querySelector(`tbody tr[data-cid="${cid}"]`);
      if (!tr) return;
      const r = res[k] || {};
      const setText = (sel, val) => { const el = tr.querySelector(sel); if (el) el.textContent = (val ?? '') === '' ? '' : String(val); };
      setText('.abs-pos', r.abs_pos);
      setText('.hcp-pos', r.hcp_pos);
      const fi = tr.querySelector('.finish-time'); if (fi) fi.value = r.finish_time || '';
      const ftc = tr.querySelector('.finish-time-cell'); if (ftc) ftc.setAttribute('sorttable_customkey', r.finish_time || '');
      setText('.on-course', r.on_course_secs);
      setText('.allowance', r.allowance);
      setText('.adj-time', r.adj_time);
      setText('.full-delta', r.full_delta);
      setText('.actual-delta', r.actual_delta);
      setText('.revised-hcp', r.revised_hcp);
      setText('.race-pts', r.race_pts);
      setText('.league-pts', r.league_pts);
    });
    finisherDiv.textContent = `Number of Finishers: ${payload?.finisher_count ?? 0}`;
    setFleetAdj(payload?.fleet_adjustment ?? '');
  }

  async function previewChanges() {
    // Only send actual changes to minimize payload
    const changedFinishTimes = [];
    for (const o of orig.finish_times) {
      const cur = finishInputs.find(i => i.dataset.cid === o.cid);
      if (!cur) continue;
      if ((cur.value || '') !== (o.value || '')) {
        const cidNum = parseInt(cur.dataset.cid, 10);
        changedFinishTimes.push({ competitor_id: isNaN(cidNum) ? cur.dataset.cid : cidNum, finish_time: cur.value });
      }
    }
    const changedOverrides = [];
    for (const o of orig.handicap_overrides) {
      const cur = hcpInputs.find(i => i.dataset.cid === o.cid);
      if (!cur) continue;
      const curVal = cur.dataset.cleared === '1' ? '' : (cur.value || '');
      if ((curVal || '') !== (o.value || '')) {
        const cidNum = parseInt(cur.dataset.cid, 10);
        changedOverrides.push({ competitor_id: isNaN(cidNum) ? cur.dataset.cid : cidNum, handicap: curVal });
      }
    }
    const payload = {
      start_time: (startTime.value || '').trim() === '' ? null : startTime.value,
      finish_times: changedFinishTimes,
      handicap_overrides: changedOverrides,
    };
    const res = await fetch('{{ url_for('main.preview_race', race_id=selected_race.race_id) }}', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify(payload)
    });
    if (!res.ok) {
      const raw = await res.text();
      let msg = raw;
      try { const j = JSON.parse(raw); msg = j.error || j.message || raw; } catch (_) {}
      throw new Error(msg || `Preview failed with status ${res.status}`);
    }
    const data = await res.json();
    applyPreviewResults(data);
    // Preview applied; preview badge removed per UI tweak
  }
  updateLocked();
  // On page load, if background recalc is active, show toast and start polling
  checkRecalcOnce().then(active => { if (active) startRecalcPolling(); });
});
</script>
{% endif %}
{% endblock %}
